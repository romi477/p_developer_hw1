# p_developer_hw1

Скрипт LogAnalyzer/log_analyzer.py - парсер логов сервера Apache. 
Для успешного выполнения в корне должен лежать html-шаблон report.html

При дефолтном запуске берёт стандартные параметры и логирует в stdout:
	LOG_DIR - директория где хранятся логи. Выбирается лог с самой свежей датой в имени.
	REPORT_DIR - директория куда выгружается готовый отчёт. Если не существует - будет создана. Если данный отчёт уже там - скрипт повторно себя не утруждает.
	REPORT_SIZE - топ отображаемых записей.

Есть возможность использовать внешний JSON конфиг:
	$ python log_analyzer.py --config [external_config_path]
Если без указания пути к внешнему конфигу (только с флагом --config), ищет дефолтный "config.json" в корне.

Во внешнем конфиге можно указать:
	LOG_FILE - файл вывода логирования. Либо в корень, либо в существующую директорию, сам путь не создаёт. Открывается на  перезапись.
	LOG_LEVEL - уровень логирования (по умолчанию "DEBUG").
	TOTAL_FAILS - процент неудачного парсинга лог файла (по умолчанию 51). При превышении отчёт не выгружается. 


Сценарий "счастливой работы" main():

1. Парсятся аргументы командной строки (get_external_config).
2. Запускается процедура обновления переменной "config" (update_config) и инициализация логирования (set_logging).
3. В директории с логами ищется нужный (find_last_log) лог. Возвращается именованный кортеж со свойствами: имя файла, распаршенная дата, оператор открытия на чтение.
4. Проверяется, а не существует ли требуемый отчёт, чтобы снова не начинать "вот это вот всё!".
5. Начинается разбор лога (log_parser).
6. Проверяется наличие в корне html-шаблона. Если ОК - начинается выгрузка отчёта (generate_report).

Запуск tests.py:
	$ python -m unittest tests.TestLogAnalyzer
	

Покаяние:

1. update_config(*args) ничего не возвращает... или лучше делать явный возврат и переприсваивание переменной "config" для наглядности?
2. Из-за того что config может искать обновление, а может не искать, set_logging(*args) вызывается два раза что не "dry", но использовать print моветон, а logging.basicConfig должно определяеться только один раз, а плодить логгеры для streamhandler и filehandler отдельно не хочется... 
3. find_last_log(*args) не послушалась рекомендации найти всё одной регуляркой за присест и не делать никакие сортировки. В любом случае, получилось две строчки, но, наверное, по чём зря используем помять...
4. log_parser(*args) создаёт два похожих объекта (urls_dict и counter_urls). Второй исключительно, чтобы было легко брать most_common(1000) записей. Опять засоряем память... На лог файле в 500Мб эти два объекта по 11Мб.
5. Ошибки непредусмотренные логикой работы никуда не прикрутил, т.к. не придумал как правильно это сделать.
6. Написав функции с возвратом кортежей, я понял что не могу написать на них тесты...


Глупые вопросы:

1. Наприер, добавил я во внешний config два новых поля (LOG_LEVEL и TOTAL_FAILS). Надо ли делать проверки типов значений? Надо ли проверять на банальные опечатки, если кто-то просто сделал ошибку, не DEBUG а DEBAG к примеру. Насколько глубоко надо в это погружаться, чтобы код не превратился в дремучий лес. В серьёзных проектах, полагаю да, но в данном случае?
2. Все функции возвращают кортежи значений (статус/требуемый объект, сообщение), что упрощает логику самой main (т.к. неуспешные статусы имеют разную природу, а значение их булево и тут на помощь приходит прикреплённый мэссэдж), но затрудняет тестирование, например. Насколько этот подход неправильный? 
3. Держа в уме с одной стороны принципы как "единственная обязанностьб чистота, идемпотентность", а с другой 100500 проверок на исключения - где надо все эти эксепшн-заборы выстраивать: в функции main - а потом, если фильтры пройдены, запускать чистую функцию; или запускать функцию - и пускай она сама из всего этого выпутывается?
4. Какая структура кода больше распространена, допустим: проверка на положительное утверждение и дальнейшее углубление в положительные проверки (получаем код зигзагом c return в конце); или проверка на отрицание, сразу return - и далее код линейный (как в данном моём случае)? Надеюсь что понятно выразился ). Возможно это азбука которую все знают, но всё же...
